{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the Demo Docs\n\n\nThis site hosts all the documentation on the demo project.\n\n\nFor full documentation on mkdocs visit \nmkdocs.org\n.\n\n\nmkdocs Commands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n\n\n\nTo Add a Page\n\n\nAdd a markdown file to the docs folder and add to the pages\nconfiguration in `mkdocs.yml`.\n\nFormat:\n    - <Page Name>: '<source file for documentation>'",
            "title": "Index"
        },
        {
            "location": "/#welcome-to-the-demo-docs",
            "text": "This site hosts all the documentation on the demo project.  For full documentation on mkdocs visit  mkdocs.org .",
            "title": "Welcome to the Demo Docs"
        },
        {
            "location": "/#mkdocs-commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "mkdocs Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/#to-add-a-page",
            "text": "Add a markdown file to the docs folder and add to the pages\nconfiguration in `mkdocs.yml`.\n\nFormat:\n    - <Page Name>: '<source file for documentation>'",
            "title": "To Add a Page"
        },
        {
            "location": "/script/",
            "text": "script - initialize the MapBox Map\n\n\nThe script.js file is a single immediately invoked JavaScript function that loads\nan instance of the Map class from Map.js with route data and a list of drivers. Map.js \\\ndefines the MapBox map, while script.js actually creates it.",
            "title": "script"
        },
        {
            "location": "/script/#script-initialize-the-mapbox-map",
            "text": "The script.js file is a single immediately invoked JavaScript function that loads\nan instance of the Map class from Map.js with route data and a list of drivers. Map.js \\\ndefines the MapBox map, while script.js actually creates it.",
            "title": "script - initialize the MapBox Map"
        },
        {
            "location": "/interface/",
            "text": "interface - Enabling jQuery\n\n\ninterface.js contains a single immediately invoked JavaScript function that wraps all\nthe jQuery methods for interacting with the map.\n\n\ninterface.js makes use of the following methods:\n\n\nPassenger Control Methods:\n\n\nDriver Control Methods:\n\n\nEvent Toggle Handler:\n\n\n$('#test-event').click(function() {\n  // Event Checkbox Toggle Listener: a jQuery listener that inverts the eventDisplay\n  // boolean attribute on the Map class and calls the toggleEvent method, also on the\n  // Map class.\n  map.eventDisplay = !map.eventDisplay;\n  map.toggleEvent();\n});\n\n\n\n\nSpeed Control Card:",
            "title": "interface"
        },
        {
            "location": "/interface/#interface-enabling-jquery",
            "text": "interface.js contains a single immediately invoked JavaScript function that wraps all\nthe jQuery methods for interacting with the map.  interface.js makes use of the following methods:",
            "title": "interface - Enabling jQuery"
        },
        {
            "location": "/interface/#passenger-control-methods",
            "text": "",
            "title": "Passenger Control Methods:"
        },
        {
            "location": "/interface/#driver-control-methods",
            "text": "",
            "title": "Driver Control Methods:"
        },
        {
            "location": "/interface/#event-toggle-handler",
            "text": "$('#test-event').click(function() {\n  // Event Checkbox Toggle Listener: a jQuery listener that inverts the eventDisplay\n  // boolean attribute on the Map class and calls the toggleEvent method, also on the\n  // Map class.\n  map.eventDisplay = !map.eventDisplay;\n  map.toggleEvent();\n});",
            "title": "Event Toggle Handler:"
        },
        {
            "location": "/interface/#speed-control-card",
            "text": "",
            "title": "Speed Control Card:"
        },
        {
            "location": "/strom_client/",
            "text": "",
            "title": "strom_client"
        },
        {
            "location": "/Map/",
            "text": "Map - Augmenting the MapBox Map\n\n\nThe Map class is an instance of the Mapbox Map with several methods for controlling\nthe drivers and routes.\n\n\nThe Map class has knowledge of:\n    - the maximum number of trips to be displayed on the map\n    - the drivers on the map (as an array of drivers)\n    - the trips\n    - the available locations\n    - a boolean attribute for whether the event display button has been toggled\n    - a count\n\n\nThe Map class makes use of the following methods:\n\n\ninitialize() {\n  // Spawn new trips every however many seconds tripSpawnInterval is set to.\n  if (this.intervalId !== 0) {\n    console.log(`Stopping: ${this.intervalId}`);\n    clearInterval(this.intervalId);\n  }\n  let myThis = this;\n  this.intervalId = setInterval(function() {\n    myThis.addTrip();\n  }, this.tripSpawnInterval);\n}\n\n\n\n\ninitDriverPool() {\n  // Create list of drivers from the list of potential drivers and initializing a socket client\n  // for each driver in the list of active drivers. We specifically make a copy tempNames of the list of\n  // potential drivers allNames so that we can remove driver names that have already been initialized.\n  // This prevents a bug where a trip with a duplicate driver name freezes on the Map.\n  this.tempNames = this.allNames.map(x => x);\n  for (let i = 0; i < this.initialDrivers; i++) {\n    let newDriver = new Driver();\n    // newDriver.name = `${this.driverFirstNames[Math.floor(Math.random() * this.driverFirstNames.length)]} ${this.driverLastNames[Math.floor(Math.random() * this.driverLastNames.length)]}`;\n    newDriver.name = this.tempNames[0];\n    this.tempNames.splice(0, 1);\n    newDriver.initClient();\n    this.drivers.push(newDriver);\n  };\n  this.activeDrivers = this.drivers.map(x => x);\n}\n\n\n\n\naddDriver() {\n  //NOTE: This is a dummy method designed to be called by the Driver Population controls\n  console.log('+1 driver...');\n  let newDriver = new Driver();\n  newDriver.initClient();\n  this.drivers.push(newDriver);\n  //TODO: Add this Driver to the map as a Symbol layer\n}\n\n\n\n\nmodifyDriverSpeed(name,modifier){\n  for (var i=0; i < this.drivers.length; i++) {\n      if (name == this.drivers[i].name){\n          this.drivers[i].setModifier(modifier);\n          //console.log(\"DRIVER: \"+this.drivers[i].name);\n          //console.log(\"modifier: \"+modifier);\n      }\n  };\n}\n\n\n\n\nremoveDriver() {\n  console.log('-1 driver...');\n  this.drivers.splice(Math.floor(Math.random() * this.drivers.length), 1);\n  //TODO: Remove driver's associated Symbol layer from the map.\n}\n\n\n\n\ntoggleEvent() {\n  // Is called by the click event handler in interface.js to flip the Trigger\n  // boolean attribute on the Trip object to determine whether events on a trip\n  // are visible.\n   console.log('toggling event');\n   map.trips.forEach(function(trip, idx) {\n     console.log('trip', trip);\n     trip.Trigger = !trip.Trigger;\n   });\n}\n\n\n\n\naddTrip() {\n  // Method to add a new trip every few seconds in the initialize method.\n  // While the number of trips on the map is fewer than the maximum number of\n  // trips to be displayed, initialize a new trip with a driver from the list\n  // of activeDrivers, and remove that driver from that list. We also need to\n  // be sure to set the Trigger attribute for each trip to match the boolean\n  // value of the eventDisplay boolean on the Map object. This ensures that\n  // newly initialized trips have a Trigger that reflects the event checkbox\n  // and not the default value of Trigger (false).\n  if (this.trips.length < this.maxTrips) {\n    if (this.activeDrivers.length >= 1) {\n      let newTrip = new Trip(this.activeDrivers[this.c]);\n      console.log(this.activeDrivers);\n      console.log(this.c);\n      this.activeDrivers[this.c].isHired = true;\n      this.activeDrivers.splice(this.c, 1);\n      // this.c++;\n      console.log(\"Got Driver in AddTrip\");\n      newTrip.Map = this;\n      // The Trigger attribute is defaulted to false for a Trip, but we want to\n      // set it in response to whether the event checkbox is true or false.\n      newTrip.Trigger = this.eventDisplay;\n      newTrip.addRoute();\n      this.trips.push(newTrip);\n      newTrip.animateRoute();\n      //TEMP: This should not be here, once we have actual drivers implemented.\n      $('#driver-pop').text(map.trips.length);\n    } else {\n      console.log(\"NO AVAILABLE DRIVER\");\n    }\n    // if(this.c < (this.initialDrivers - 1)) {\n    //   this.c++;\n    // }else {\n    //   this.c = 0;\n    // };\n  }\n}\n\n\n\n\nrouteCall() {\n  // http request for the route data from the sqlite3 database.\n  return $.ajax({\n    url: 'db/routes',\n    dataType: 'json',\n    type: 'GET'\n  });\n}\n\n\n\n\nsetRoutes() {\n  // use AJAX route response to initialize as Route object and store in array\n  let thus = this;\n  this.routeCall().then(function(response) {\n    for (let i = 0; i < response.length; i++) {\n      let newRoute = new Route(response[i][0], response[i][1], JSON.parse(response[i][2]), JSON.parse(response[i][3]), response[i][4], response[i][5], JSON.parse(response[i][6]));\n      thus.routes.push(newRoute);\n    };\n  });\n}\n\n\n\n\nasync setRoutesHelper() {\n  // async helper\n  await this.setRoutes();\n}\n\n\n\n\nasync setLocations() {   \n  // method for initializing locations as Points and storing them in Map object, currently not used\n  let result = await $.ajax({\n    url: 'db/read',\n    dataType: 'json'\n  });\n  for (let i = 0; i < result.length; i++) {\n    let location = new Point(result[i][0], result[i][1], result[i][2]);\n    this.locations.push(location);\n  };\n}",
            "title": "Map"
        },
        {
            "location": "/Map/#map-augmenting-the-mapbox-map",
            "text": "The Map class is an instance of the Mapbox Map with several methods for controlling\nthe drivers and routes.  The Map class has knowledge of:\n    - the maximum number of trips to be displayed on the map\n    - the drivers on the map (as an array of drivers)\n    - the trips\n    - the available locations\n    - a boolean attribute for whether the event display button has been toggled\n    - a count  The Map class makes use of the following methods:  initialize() {\n  // Spawn new trips every however many seconds tripSpawnInterval is set to.\n  if (this.intervalId !== 0) {\n    console.log(`Stopping: ${this.intervalId}`);\n    clearInterval(this.intervalId);\n  }\n  let myThis = this;\n  this.intervalId = setInterval(function() {\n    myThis.addTrip();\n  }, this.tripSpawnInterval);\n}  initDriverPool() {\n  // Create list of drivers from the list of potential drivers and initializing a socket client\n  // for each driver in the list of active drivers. We specifically make a copy tempNames of the list of\n  // potential drivers allNames so that we can remove driver names that have already been initialized.\n  // This prevents a bug where a trip with a duplicate driver name freezes on the Map.\n  this.tempNames = this.allNames.map(x => x);\n  for (let i = 0; i < this.initialDrivers; i++) {\n    let newDriver = new Driver();\n    // newDriver.name = `${this.driverFirstNames[Math.floor(Math.random() * this.driverFirstNames.length)]} ${this.driverLastNames[Math.floor(Math.random() * this.driverLastNames.length)]}`;\n    newDriver.name = this.tempNames[0];\n    this.tempNames.splice(0, 1);\n    newDriver.initClient();\n    this.drivers.push(newDriver);\n  };\n  this.activeDrivers = this.drivers.map(x => x);\n}  addDriver() {\n  //NOTE: This is a dummy method designed to be called by the Driver Population controls\n  console.log('+1 driver...');\n  let newDriver = new Driver();\n  newDriver.initClient();\n  this.drivers.push(newDriver);\n  //TODO: Add this Driver to the map as a Symbol layer\n}  modifyDriverSpeed(name,modifier){\n  for (var i=0; i < this.drivers.length; i++) {\n      if (name == this.drivers[i].name){\n          this.drivers[i].setModifier(modifier);\n          //console.log(\"DRIVER: \"+this.drivers[i].name);\n          //console.log(\"modifier: \"+modifier);\n      }\n  };\n}  removeDriver() {\n  console.log('-1 driver...');\n  this.drivers.splice(Math.floor(Math.random() * this.drivers.length), 1);\n  //TODO: Remove driver's associated Symbol layer from the map.\n}  toggleEvent() {\n  // Is called by the click event handler in interface.js to flip the Trigger\n  // boolean attribute on the Trip object to determine whether events on a trip\n  // are visible.\n   console.log('toggling event');\n   map.trips.forEach(function(trip, idx) {\n     console.log('trip', trip);\n     trip.Trigger = !trip.Trigger;\n   });\n}  addTrip() {\n  // Method to add a new trip every few seconds in the initialize method.\n  // While the number of trips on the map is fewer than the maximum number of\n  // trips to be displayed, initialize a new trip with a driver from the list\n  // of activeDrivers, and remove that driver from that list. We also need to\n  // be sure to set the Trigger attribute for each trip to match the boolean\n  // value of the eventDisplay boolean on the Map object. This ensures that\n  // newly initialized trips have a Trigger that reflects the event checkbox\n  // and not the default value of Trigger (false).\n  if (this.trips.length < this.maxTrips) {\n    if (this.activeDrivers.length >= 1) {\n      let newTrip = new Trip(this.activeDrivers[this.c]);\n      console.log(this.activeDrivers);\n      console.log(this.c);\n      this.activeDrivers[this.c].isHired = true;\n      this.activeDrivers.splice(this.c, 1);\n      // this.c++;\n      console.log(\"Got Driver in AddTrip\");\n      newTrip.Map = this;\n      // The Trigger attribute is defaulted to false for a Trip, but we want to\n      // set it in response to whether the event checkbox is true or false.\n      newTrip.Trigger = this.eventDisplay;\n      newTrip.addRoute();\n      this.trips.push(newTrip);\n      newTrip.animateRoute();\n      //TEMP: This should not be here, once we have actual drivers implemented.\n      $('#driver-pop').text(map.trips.length);\n    } else {\n      console.log(\"NO AVAILABLE DRIVER\");\n    }\n    // if(this.c < (this.initialDrivers - 1)) {\n    //   this.c++;\n    // }else {\n    //   this.c = 0;\n    // };\n  }\n}  routeCall() {\n  // http request for the route data from the sqlite3 database.\n  return $.ajax({\n    url: 'db/routes',\n    dataType: 'json',\n    type: 'GET'\n  });\n}  setRoutes() {\n  // use AJAX route response to initialize as Route object and store in array\n  let thus = this;\n  this.routeCall().then(function(response) {\n    for (let i = 0; i < response.length; i++) {\n      let newRoute = new Route(response[i][0], response[i][1], JSON.parse(response[i][2]), JSON.parse(response[i][3]), response[i][4], response[i][5], JSON.parse(response[i][6]));\n      thus.routes.push(newRoute);\n    };\n  });\n}  async setRoutesHelper() {\n  // async helper\n  await this.setRoutes();\n}  async setLocations() {   \n  // method for initializing locations as Points and storing them in Map object, currently not used\n  let result = await $.ajax({\n    url: 'db/read',\n    dataType: 'json'\n  });\n  for (let i = 0; i < result.length; i++) {\n    let location = new Point(result[i][0], result[i][1], result[i][2]);\n    this.locations.push(location);\n  };\n}",
            "title": "Map - Augmenting the MapBox Map"
        },
        {
            "location": "/Trip/",
            "text": "Trip - Animating a Ride\n\n\nThe Trip class is initialized by a driver object from the activeDrivers list on the Map object, and contains all the functions for animating a trip from an origin to a destination.\n\n\nThe Trip class has knowledge of:\n    - Id: a unique identifier\n    - Driver: its driver\n    - Route: its route data\n    - arrayLimiter: the size of packets sent to the server\n    - Speed:\n    - locationTempArr: an empty dummy array of location data prior to requesting the real location\n    data from the database.\n    - locationStreamArr: the array of trip coordinates from the database.\n    - Color: the color of the trip (no longer used)\n    - Trigger: a boolean value (defaulted to false) for controlling visibility of events\n    - SpeedVector:\n    - tripTurns:\n\n\nThe Trip class makes use of the following methods:\n\n\nsetupLocationArr() {\n  if (this.locationTempArr.length == this.arrayLimiter) {\n    let data = this.locationTempArr.map(x => x);\n    this.Driver.Client.process(this.Driver.name, this.Driver.name.replace(/\\s/g, \"\"), data);\n    let rollOver = this.locationTempArr.pop();\n    this.locationTempArr.splice(0);\n    this.locationTempArr.push(rollOver);\n    sensorFailureCount = 0;\n  }\n}\n\n\n\n\nsendDataAjax(data) {\n  // sends a packet of geo-codes to server to be streamed\n  $.ajax({\n    url: 'stream/collect',\n    type: 'POST',\n    data: data,\n    dataType: 'json',\n    success: console.log('data sent')\n  });\n}\n\n\n\n\naddRoute() {\n  var rand = Math.floor(Math.random() * (this.Map.routes.length));\n  this.Route = this.Map.routes[rand];\n  this.Driver.location = this.Route.originCoords;\n  this.SpeedVector = this.Route.speedVector.map(x => x);\n}\n\n\n\n\nemitNoisy(failPercent, minorAbbPercent, majorAbbPercent) {\n  let src = this.Map.getSource(`point-${this.Id}`);\n  let loc = src._options.data.features[0].geometry.coordinates;\n  // Add noise to location.\n  // NOTE: 1 block ~ .001 lat/lng. Also, lat/lng numbers have 14 decimal places.\n  if (Math.random() * 101 < minorAbbPercent) {\n    loc = loc.map(e => {\n      let abb = (Math.random() * .001).toPrecision(11);\n      if (Math.floor(Math.random() * 2) == 0) {\n        e += abb;\n      } else {\n        e -= abb;\n      }\n    });\n  }\n\n  // Major abberations are the same as minor ones, but an order of magnitude larger.\n  if (Math.random() * 101 < majorAbbPercent) {\n    loc = loc.map(e => {\n      let abb = (Math.random() * .01).toPrecision(12);\n      if (Math.floor(Math.random() * 2) == 0) {\n        e += abb;\n      } else {\n        e -= abb;\n      }\n    });\n  }\n\n  // Package up to object to be sent to aggregation systems.\n  let objectToEmit = {\n    'id': this.Id,\n    'location': loc,\n    'timestamp': null,\n    'driver-id': this.Driver.name,\n    'region-code': 'PDX'\n  };\n\n  let tk = new Date();\n  objectToEmit.timestamp = tk.getTime();\n  // Push data to array if we didn't roll fail-to-emit\n  if (Math.random() * 101 > failPercent) {\n    if(this.locationTempArr.length <= this.arrayLimiter) {\n      this.locationTempArr.push(this.Driver.Client.formatData(this.Driver.template, objectToEmit));\n    };\n  } else {\n    sensorFailureCount++;\n  }\n\n  this.setupLocationArr(); //check if array is full every cycle | NOTE: this line (and the import of kafka.py) enables streaming\n}\n\n\n\n\nanimateRoute() {\n  // A path line from origin to destination.\n  var route = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'LineString',\n              'coordinates': this.Route.coords\n          }\n      }]\n  };\n  // A single point that animates along the route. The \"driver.\"\n  // Coordinates are initially set to origin.\n  var point = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'Point',\n              'coordinates': this.Route.originCoords\n          }\n      }]\n  };\n\n  // The location of an event.\n  var eventPoint = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'Point',\n              'coordinates': this.Route.originCoords\n          }\n      }]\n  };\n\n  for(let i = 0; i < this.Map.drivers.length; i++) {\n    if(this.Map.drivers[i].location == undefined) {\n      this.Map.drivers[i].location = this.Route.originCoords;\n    };\n  };\n\n  // The target destination of a trip.\n  let dest = {\n    'type': 'FeatureCollection',\n    'features': [{\n        'type': 'Feature',\n        'geometry': {\n            'type': 'Point',\n            'coordinates': this.Route.destCoords\n        }\n    }]\n  };\n\n  // Calculate the distance in kilometers between route start/end point.\n  var lineDistance = turf.lineDistance(route.features[0], 'kilometers');\n  var tweens = [];\n\n  var numberOfFrames = 0;\n  // NOTE: One possible optimization route is decreasing the resolution of the animations. I've made that easily controllable from within source by adding the variable below:\n  var resolution = 40;\n  // Draw an arc between the `origin` & `destination` of the two points\n  for (var i = 0; i < resolution * lineDistance; i++) {\n      var segment = turf.along(route.features[0], i / resolution, 'kilometers');\n      tweens.push(segment.geometry.coordinates);\n      numberOfFrames ++;\n  }\n  // console.log(`Frames in route: ${numberOfFrames}`);\n\n  // Update the route with calculated arc coordinates\n  route.features[0].geometry.coordinates = tweens;\n\n  this.Map.addSource(`route-${this.Id}`, {\n      'type': 'geojson',\n      'data': route\n  });\n\n  this.Map.addSource(`point-${this.Id}`, {\n      'type': 'geojson',\n      'data': point\n  });\n\n  this.Map.addSource(`event-point-${this.Id}`, {\n      'type': 'geojson',\n      'data': eventPoint\n  });\n\n  this.Map.addSource(`dest-${this.Id}`, {\n      'type': 'geojson',\n      'data': dest\n  });\n\n  this.Map.addLayer({\n    'id': `trip-route-${this.Id}`,\n    'source': `route-${this.Id}`,\n    'type': 'line',\n    'paint': {\n      'line-width': 4,\n      'line-color': this.Color,\n      'line-opacity': .4\n    }\n  });\n\n  this.Map.addLayer({\n      'id': `trip-point-${this.Id}`,\n      'source': `point-${this.Id}`,\n      'type': 'circle',\n      'paint': {\n          'circle-radius': 8,\n          'circle-color': this.Color,\n          'circle-translate': [5,-5]\n      }\n  });\n\n  this.Map.addLayer({\n    'id': `trip-dest-${this.Id}`,\n    'source': `dest-${this.Id}`,\n    'type': 'symbol',\n    'layout': {\n        'icon-image': 'alcohol-shop-15',\n        'icon-offset': [0, 0],\n        'text-offset': [0, 1],\n        'text-field':  this.Driver.name\n    },\n    'paint': {\n        'icon-color': this.Color,\n    }\n  });\n\n  // add invisible layer to show events\n  this.Map.addLayer({\n    'id': `event-${this.Id}`,\n    'source': `event-point-${this.Id}`,\n    'type': 'symbol',\n    'layout': {\n      'text-offset': [0, 0]\n    }\n  });\n\n  // Store the context of `this` using a variable so we can refer to the Trip object\n  // as `this` inside functions.\n  let myThis = this;\n\n  function denoteTurn() {\n    console.log(\"denoting turn\");\n    // Set the location of the eventPoint to the turn coordinates from the socket stream.\n    eventPoint.features[0].geometry.coordinates = myThis.Driver.turnCoords;\n    if (eventPoint && myThis.Map.getSource(`event-point-${myThis.Id}`)) {\n        myThis.Map.getSource(`event-point-${myThis.Id}`).setData(eventPoint);\n    }\n    // Define and render a Mapbox layer that contains a text-field that says \"Turn\".\n    myThis.Map.setLayoutProperty(`event-${myThis.Id}`, 'text-field', 'Turn');\n    // Use a variable to preserve the context of `this` for the Trip object.\n    let thus = myThis;\n    // Toggle visibility off of the event by setting the text-field to an empty\n    // string.\n    setTimeout(function() {\n      thus.Map.setLayoutProperty(`event-${thus.Id}`, 'text-field', \"\");\n    }, 500);\n  }\n\n  function turnCheck() {\n    if (myThis.Driver.turnCount > myThis.tripTurns) {\n      myThis.tripTurns +=1;\n      console.log(\"turn check\");\n      console.log(myThis.tripTurns);\n      if (myThis.Trigger) {\n        console.log(\"Trigger TRUE\")\n        denoteTurn();\n      }\n    }\n  }\n\n  function animate() {\n      //Shorten route geometry and Route speed vector\n      if (route.features[0].geometry.coordinates.length > 1) {\n        route.features[0].geometry.coordinates.splice(0, 1);\n        myThis.SpeedVector.splice(0, 1);\n      }\n      // Update point geometry to a new position based on counter denoting\n      // the index to access the arc.\n      point.features[0].geometry.coordinates = route.features[0].geometry.coordinates[0];\n      myThis.Driver.location = route.features[0].geometry.coordinates[0];\n      if (!isNaN(Math.floor(myThis.SpeedVector[0]))){\n          myThis.Speed = myThis.SpeedVector[0] + parseInt(myThis.Driver.speedModifier);\n      } //else if (myThis.Speed == 85) {\n      //     console.log(\"I'm a bad route! I started at \" + myThis.Route.origin + \" and I ended at \" + myThis.Route.destination);\n      //     console.log(myThis.Route.speedVector);\n      // }\n\n      if (myThis.Speed >= 96) {\n          myThis.Color = '#2196f3'\n      } else if (myThis.Speed >= 91) {\n          myThis.Color = '#5961D3'\n      } else if (myThis.Speed >= 86) {\n          myThis.Color = '#6D56C0'\n      } else if (myThis.Speed >= 81) {\n          myThis.Color = '#8646A6'\n      }else if (myThis.Speed >= 76) {\n          myThis.Color = '#B02E7F'\n      }else if (myThis.Speed >= 71) {\n          myThis.Color = '#CB1E64'\n      }else if (myThis.Speed >= 66) {\n          myThis.Color = '#E70E48'\n      } else {\n          myThis.Color = '#f44336'\n      }\n\n      // Update the route source with the new data.\n      myThis.Map.getSource(`route-${myThis.Id}`).setData(route);\n      myThis.Map.setPaintProperty(`trip-route-${myThis.Id}`, 'line-color', myThis.Color);\n      // Update the color of the circles\n      myThis.Map.setPaintProperty(`trip-point-${myThis.Id}`,'circle-color', myThis.Color)\n      // Update the source with this new data.\n      myThis.Map.getSource(`point-${myThis.Id}`).setData(point);\n      //myThis.Map.getSource(`event-point-${myThis.Id}`).setData(point);\n\n      // Set the value of the Trigger attribute to the value of the eventDisplay attribute on the Map\n      // object. We do this before calling turnCheck to make sure that we have the \"right\" boolean\n      // value to display - or not display - any potential turns.\n      myThis.Trigger = map.eventDisplay;\n\n      turnCheck();\n\n      myThis.emitNoisy(0, 0, 0);\n      // Request the next frame of animation so long as destination has not\n      // been reached.\n      if (point.features[0].geometry.coordinates[0]\n          !==\n          route.features[0].geometry.coordinates[route.features[0].geometry.coordinates.length - 1][0]) {\n        setTimeout(function() {\n          requestAnimationFrame(animate);\n        }, myThis.Speed);\n      } else {\n        myThis.complete();\n      }\n  }\n\n  // Start the animation.\n  animate();\n}\n\n\n\n\ncomplete() {\n  // Remove driver of Trip from the list of active drivers on the Map object.\n  this.Map.activeDrivers.push(this.Driver);\n  this.Driver.turnCount = 0;\n  // remove trip from those listed on the map\n  this.Map.trips.splice(\n  this.Map.trips.indexOf(e => e.Id === this.Id), 1);\n  this.Driver.isHired = false;\n  // remove point and route layers from the map\n  if (parseInt(this.Id) > 2) {\n      let last_id = parseInt(this.Id) - 2;\n      this.Map.removeLayer(`event-${last_id}`);\n      this.Map.removeSource(`event-point-${last_id}`);\n  }\n  // Remove trip layer from the map.\n  this.Map.removeLayer(`trip-route-${this.Id}`);\n  this.Map.removeLayer(`trip-point-${this.Id}`);\n  this.Map.removeLayer(`trip-dest-${this.Id}`);\n  // remove sources from the map\n  this.Map.removeSource(`route-${this.Id}`);\n  this.Map.removeSource(`point-${this.Id}`);\n  this.Map.removeSource(`dest-${this.Id}`);\n}",
            "title": "Trip"
        },
        {
            "location": "/Trip/#trip-animating-a-ride",
            "text": "The Trip class is initialized by a driver object from the activeDrivers list on the Map object, and contains all the functions for animating a trip from an origin to a destination.  The Trip class has knowledge of:\n    - Id: a unique identifier\n    - Driver: its driver\n    - Route: its route data\n    - arrayLimiter: the size of packets sent to the server\n    - Speed:\n    - locationTempArr: an empty dummy array of location data prior to requesting the real location\n    data from the database.\n    - locationStreamArr: the array of trip coordinates from the database.\n    - Color: the color of the trip (no longer used)\n    - Trigger: a boolean value (defaulted to false) for controlling visibility of events\n    - SpeedVector:\n    - tripTurns:  The Trip class makes use of the following methods:  setupLocationArr() {\n  if (this.locationTempArr.length == this.arrayLimiter) {\n    let data = this.locationTempArr.map(x => x);\n    this.Driver.Client.process(this.Driver.name, this.Driver.name.replace(/\\s/g, \"\"), data);\n    let rollOver = this.locationTempArr.pop();\n    this.locationTempArr.splice(0);\n    this.locationTempArr.push(rollOver);\n    sensorFailureCount = 0;\n  }\n}  sendDataAjax(data) {\n  // sends a packet of geo-codes to server to be streamed\n  $.ajax({\n    url: 'stream/collect',\n    type: 'POST',\n    data: data,\n    dataType: 'json',\n    success: console.log('data sent')\n  });\n}  addRoute() {\n  var rand = Math.floor(Math.random() * (this.Map.routes.length));\n  this.Route = this.Map.routes[rand];\n  this.Driver.location = this.Route.originCoords;\n  this.SpeedVector = this.Route.speedVector.map(x => x);\n}  emitNoisy(failPercent, minorAbbPercent, majorAbbPercent) {\n  let src = this.Map.getSource(`point-${this.Id}`);\n  let loc = src._options.data.features[0].geometry.coordinates;\n  // Add noise to location.\n  // NOTE: 1 block ~ .001 lat/lng. Also, lat/lng numbers have 14 decimal places.\n  if (Math.random() * 101 < minorAbbPercent) {\n    loc = loc.map(e => {\n      let abb = (Math.random() * .001).toPrecision(11);\n      if (Math.floor(Math.random() * 2) == 0) {\n        e += abb;\n      } else {\n        e -= abb;\n      }\n    });\n  }\n\n  // Major abberations are the same as minor ones, but an order of magnitude larger.\n  if (Math.random() * 101 < majorAbbPercent) {\n    loc = loc.map(e => {\n      let abb = (Math.random() * .01).toPrecision(12);\n      if (Math.floor(Math.random() * 2) == 0) {\n        e += abb;\n      } else {\n        e -= abb;\n      }\n    });\n  }\n\n  // Package up to object to be sent to aggregation systems.\n  let objectToEmit = {\n    'id': this.Id,\n    'location': loc,\n    'timestamp': null,\n    'driver-id': this.Driver.name,\n    'region-code': 'PDX'\n  };\n\n  let tk = new Date();\n  objectToEmit.timestamp = tk.getTime();\n  // Push data to array if we didn't roll fail-to-emit\n  if (Math.random() * 101 > failPercent) {\n    if(this.locationTempArr.length <= this.arrayLimiter) {\n      this.locationTempArr.push(this.Driver.Client.formatData(this.Driver.template, objectToEmit));\n    };\n  } else {\n    sensorFailureCount++;\n  }\n\n  this.setupLocationArr(); //check if array is full every cycle | NOTE: this line (and the import of kafka.py) enables streaming\n}  animateRoute() {\n  // A path line from origin to destination.\n  var route = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'LineString',\n              'coordinates': this.Route.coords\n          }\n      }]\n  };\n  // A single point that animates along the route. The \"driver.\"\n  // Coordinates are initially set to origin.\n  var point = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'Point',\n              'coordinates': this.Route.originCoords\n          }\n      }]\n  };\n\n  // The location of an event.\n  var eventPoint = {\n      'type': 'FeatureCollection',\n      'features': [{\n          'type': 'Feature',\n          'geometry': {\n              'type': 'Point',\n              'coordinates': this.Route.originCoords\n          }\n      }]\n  };\n\n  for(let i = 0; i < this.Map.drivers.length; i++) {\n    if(this.Map.drivers[i].location == undefined) {\n      this.Map.drivers[i].location = this.Route.originCoords;\n    };\n  };\n\n  // The target destination of a trip.\n  let dest = {\n    'type': 'FeatureCollection',\n    'features': [{\n        'type': 'Feature',\n        'geometry': {\n            'type': 'Point',\n            'coordinates': this.Route.destCoords\n        }\n    }]\n  };\n\n  // Calculate the distance in kilometers between route start/end point.\n  var lineDistance = turf.lineDistance(route.features[0], 'kilometers');\n  var tweens = [];\n\n  var numberOfFrames = 0;\n  // NOTE: One possible optimization route is decreasing the resolution of the animations. I've made that easily controllable from within source by adding the variable below:\n  var resolution = 40;\n  // Draw an arc between the `origin` & `destination` of the two points\n  for (var i = 0; i < resolution * lineDistance; i++) {\n      var segment = turf.along(route.features[0], i / resolution, 'kilometers');\n      tweens.push(segment.geometry.coordinates);\n      numberOfFrames ++;\n  }\n  // console.log(`Frames in route: ${numberOfFrames}`);\n\n  // Update the route with calculated arc coordinates\n  route.features[0].geometry.coordinates = tweens;\n\n  this.Map.addSource(`route-${this.Id}`, {\n      'type': 'geojson',\n      'data': route\n  });\n\n  this.Map.addSource(`point-${this.Id}`, {\n      'type': 'geojson',\n      'data': point\n  });\n\n  this.Map.addSource(`event-point-${this.Id}`, {\n      'type': 'geojson',\n      'data': eventPoint\n  });\n\n  this.Map.addSource(`dest-${this.Id}`, {\n      'type': 'geojson',\n      'data': dest\n  });\n\n  this.Map.addLayer({\n    'id': `trip-route-${this.Id}`,\n    'source': `route-${this.Id}`,\n    'type': 'line',\n    'paint': {\n      'line-width': 4,\n      'line-color': this.Color,\n      'line-opacity': .4\n    }\n  });\n\n  this.Map.addLayer({\n      'id': `trip-point-${this.Id}`,\n      'source': `point-${this.Id}`,\n      'type': 'circle',\n      'paint': {\n          'circle-radius': 8,\n          'circle-color': this.Color,\n          'circle-translate': [5,-5]\n      }\n  });\n\n  this.Map.addLayer({\n    'id': `trip-dest-${this.Id}`,\n    'source': `dest-${this.Id}`,\n    'type': 'symbol',\n    'layout': {\n        'icon-image': 'alcohol-shop-15',\n        'icon-offset': [0, 0],\n        'text-offset': [0, 1],\n        'text-field':  this.Driver.name\n    },\n    'paint': {\n        'icon-color': this.Color,\n    }\n  });\n\n  // add invisible layer to show events\n  this.Map.addLayer({\n    'id': `event-${this.Id}`,\n    'source': `event-point-${this.Id}`,\n    'type': 'symbol',\n    'layout': {\n      'text-offset': [0, 0]\n    }\n  });\n\n  // Store the context of `this` using a variable so we can refer to the Trip object\n  // as `this` inside functions.\n  let myThis = this;\n\n  function denoteTurn() {\n    console.log(\"denoting turn\");\n    // Set the location of the eventPoint to the turn coordinates from the socket stream.\n    eventPoint.features[0].geometry.coordinates = myThis.Driver.turnCoords;\n    if (eventPoint && myThis.Map.getSource(`event-point-${myThis.Id}`)) {\n        myThis.Map.getSource(`event-point-${myThis.Id}`).setData(eventPoint);\n    }\n    // Define and render a Mapbox layer that contains a text-field that says \"Turn\".\n    myThis.Map.setLayoutProperty(`event-${myThis.Id}`, 'text-field', 'Turn');\n    // Use a variable to preserve the context of `this` for the Trip object.\n    let thus = myThis;\n    // Toggle visibility off of the event by setting the text-field to an empty\n    // string.\n    setTimeout(function() {\n      thus.Map.setLayoutProperty(`event-${thus.Id}`, 'text-field', \"\");\n    }, 500);\n  }\n\n  function turnCheck() {\n    if (myThis.Driver.turnCount > myThis.tripTurns) {\n      myThis.tripTurns +=1;\n      console.log(\"turn check\");\n      console.log(myThis.tripTurns);\n      if (myThis.Trigger) {\n        console.log(\"Trigger TRUE\")\n        denoteTurn();\n      }\n    }\n  }\n\n  function animate() {\n      //Shorten route geometry and Route speed vector\n      if (route.features[0].geometry.coordinates.length > 1) {\n        route.features[0].geometry.coordinates.splice(0, 1);\n        myThis.SpeedVector.splice(0, 1);\n      }\n      // Update point geometry to a new position based on counter denoting\n      // the index to access the arc.\n      point.features[0].geometry.coordinates = route.features[0].geometry.coordinates[0];\n      myThis.Driver.location = route.features[0].geometry.coordinates[0];\n      if (!isNaN(Math.floor(myThis.SpeedVector[0]))){\n          myThis.Speed = myThis.SpeedVector[0] + parseInt(myThis.Driver.speedModifier);\n      } //else if (myThis.Speed == 85) {\n      //     console.log(\"I'm a bad route! I started at \" + myThis.Route.origin + \" and I ended at \" + myThis.Route.destination);\n      //     console.log(myThis.Route.speedVector);\n      // }\n\n      if (myThis.Speed >= 96) {\n          myThis.Color = '#2196f3'\n      } else if (myThis.Speed >= 91) {\n          myThis.Color = '#5961D3'\n      } else if (myThis.Speed >= 86) {\n          myThis.Color = '#6D56C0'\n      } else if (myThis.Speed >= 81) {\n          myThis.Color = '#8646A6'\n      }else if (myThis.Speed >= 76) {\n          myThis.Color = '#B02E7F'\n      }else if (myThis.Speed >= 71) {\n          myThis.Color = '#CB1E64'\n      }else if (myThis.Speed >= 66) {\n          myThis.Color = '#E70E48'\n      } else {\n          myThis.Color = '#f44336'\n      }\n\n      // Update the route source with the new data.\n      myThis.Map.getSource(`route-${myThis.Id}`).setData(route);\n      myThis.Map.setPaintProperty(`trip-route-${myThis.Id}`, 'line-color', myThis.Color);\n      // Update the color of the circles\n      myThis.Map.setPaintProperty(`trip-point-${myThis.Id}`,'circle-color', myThis.Color)\n      // Update the source with this new data.\n      myThis.Map.getSource(`point-${myThis.Id}`).setData(point);\n      //myThis.Map.getSource(`event-point-${myThis.Id}`).setData(point);\n\n      // Set the value of the Trigger attribute to the value of the eventDisplay attribute on the Map\n      // object. We do this before calling turnCheck to make sure that we have the \"right\" boolean\n      // value to display - or not display - any potential turns.\n      myThis.Trigger = map.eventDisplay;\n\n      turnCheck();\n\n      myThis.emitNoisy(0, 0, 0);\n      // Request the next frame of animation so long as destination has not\n      // been reached.\n      if (point.features[0].geometry.coordinates[0]\n          !==\n          route.features[0].geometry.coordinates[route.features[0].geometry.coordinates.length - 1][0]) {\n        setTimeout(function() {\n          requestAnimationFrame(animate);\n        }, myThis.Speed);\n      } else {\n        myThis.complete();\n      }\n  }\n\n  // Start the animation.\n  animate();\n}  complete() {\n  // Remove driver of Trip from the list of active drivers on the Map object.\n  this.Map.activeDrivers.push(this.Driver);\n  this.Driver.turnCount = 0;\n  // remove trip from those listed on the map\n  this.Map.trips.splice(\n  this.Map.trips.indexOf(e => e.Id === this.Id), 1);\n  this.Driver.isHired = false;\n  // remove point and route layers from the map\n  if (parseInt(this.Id) > 2) {\n      let last_id = parseInt(this.Id) - 2;\n      this.Map.removeLayer(`event-${last_id}`);\n      this.Map.removeSource(`event-point-${last_id}`);\n  }\n  // Remove trip layer from the map.\n  this.Map.removeLayer(`trip-route-${this.Id}`);\n  this.Map.removeLayer(`trip-point-${this.Id}`);\n  this.Map.removeLayer(`trip-dest-${this.Id}`);\n  // remove sources from the map\n  this.Map.removeSource(`route-${this.Id}`);\n  this.Map.removeSource(`point-${this.Id}`);\n  this.Map.removeSource(`dest-${this.Id}`);\n}",
            "title": "Trip - Animating a Ride"
        },
        {
            "location": "/Driver/",
            "text": "Driver\n\n\nThe Driver class inherits from the Person class (which is only a JavaScript object with a name attribute)\nand is initialized with a location and isHired attributes.",
            "title": "Driver"
        },
        {
            "location": "/Driver/#driver",
            "text": "The Driver class inherits from the Person class (which is only a JavaScript object with a name attribute)\nand is initialized with a location and isHired attributes.",
            "title": "Driver"
        },
        {
            "location": "/Route/",
            "text": "",
            "title": "Route"
        },
        {
            "location": "/Point/",
            "text": "",
            "title": "Point"
        }
    ]
}